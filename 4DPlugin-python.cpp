/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-python.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : python
 #	author : miyako
 #	2021/11/17
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-python.h"

#pragma mark -

#if VERSIONMAC
static bool getPythonHome(std::wstring& path) {

    NSBundle *thisBundle = [NSBundle bundleWithIdentifier:THIS_BUNDLE_ID];
    if(thisBundle){
        NSString *str = [[thisBundle resourcePath]stringByAppendingPathComponent:@"python"];
        if(str){
            NSData *u32 = [str dataUsingEncoding:NSUTF32LittleEndianStringEncoding];//default is BE
            path = std::wstring((wchar_t *)[u32 bytes], wcslen((wchar_t *)[u32 bytes]));
            return true;
         }
        
    }
    
    return false;
}
#else
static bool getPythonHome(std::wstring& path) {
    
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    
    wchar_t thisPath[_MAX_PATH] = {0};
    wchar_t resourcesPath[_MAX_PATH] = {0};
    wchar_t python_path[_MAX_PATH] = {0};
    
    HMODULE hplugin = GetModuleHandleW(THIS_BUNDLE_NAME);
    GetModuleFileNameW(hplugin, thisPath, _MAX_PATH);
    
    _wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);
    
    wstring windowsPath = fDrive;
    windowsPath += fDir;
    if(windowsPath.at(windowsPath.size() - 1) == L'\\')
        windowsPath = windowsPath.substr(0, windowsPath.size() - 1);
    
    _wsplitpath_s(windowsPath.c_str(), fDrive, fDir, fName, fExt);
    _wmakepath_s(resourcesPath, fDrive, fDir, L"Resources\\", NULL);
    
    _wsplitpath_s(resourcesPath, fDrive, fDir, fName, fExt);
    _wmakepath_s(python_path, fDrive, fDir, L"python", NULL);
    
    path = std::wstring(python_path);
    
    return true;
}
#endif

static void OnSartup() {

    std::wstring path;
    
    if(getPythonHome(path)) {
 
        Py_SetPythonHome((wchar_t *)path.c_str());

        //https://docs.python.org/3.6/c-api/init.html
        
        Py_NoSiteFlag = 1;
        Py_IgnoreEnvironmentFlag = 1;
        Py_NoUserSiteDirectory = 1;
        
//        Py_UnbufferedStdioFlag = 1;
        
        Py_InitializeEx(0);
        
        printf("Python %s on %s\n", Py_GetVersion(), Py_GetPlatform());
 
    }
        
}

static void OnExit() {
    Py_FinalizeEx();
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin:
            case kServerInitPlugin:
                OnSartup();
                //PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnSartup, NULL);
                break;
                
            case kDeinitPlugin:
            case kServerDeinitPlugin:
                OnExit();
                //PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit  , NULL);
                break;
                
			// --- python
            
			case 1 :
				python(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void python(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    ob_set_b(status, L"success", false);

    std::string python;
    
    PA_Unistring *arg1 = PA_GetStringParameter(params, 1);
    if(arg1){
        CUTF16String u16 = (const PA_Unichar *)PA_GetUnistring(arg1);
        u16_to_u8(u16, python);
    }
    
    int res = 0;
        
    res = PyRun_SimpleString(python.c_str());

    ob_set_b(status, L"success", res == 0);
    
    PA_ReturnObject(params, status);
}

#pragma mark -

static void u16_to_u8(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
        u8 = std::string((const char *)"");
    }

#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void u8_to_u16(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}
